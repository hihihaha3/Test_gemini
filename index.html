<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>H·ªá Th·ªëng AR - ƒêinh Quang Trung</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        
        /* Video camera l√†m n·ªÅn */
        .camera-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); /* G∆∞∆°ng */
            z-index: 0; opacity: 0.6; /* L√†m t·ªëi camera ƒë·ªÉ h·∫°t n·ªïi h∆°n */
        }
        
        /* Video input ·∫©n cho AI x·ª≠ l√Ω */
        #input_video { display: none; }

        .glass-panel {
            background: rgba(10, 10, 10, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
        }

        /* M√†n h√¨nh ch·ªù & N√∫t b·∫•m */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #00ffff; text-align: center;
        }
        .start-btn {
            margin-top: 20px; padding: 15px 40px;
            background: transparent; border: 2px solid #00ffff; color: #00ffff;
            font-size: 1.2rem; font-weight: bold; border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: 0.3s;
        }
        .start-btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 30px #00ffff; }
        .error-msg { color: #ff3333; margin-top: 10px; font-size: 0.9rem; max-width: 80%; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1 class="text-3xl font-bold mb-2 tracking-widest">SYSTEM INITIALIZING</h1>
        <p class="text-gray-400 text-sm mb-8">User: ƒêinh Quang Trung</p>
        
        <button id="btn-start" class="start-btn" onclick="startSystem()">
            K√çCH HO·∫†T CAMERA
        </button>
        
        <div id="status-msg" class="mt-4 text-gray-500 text-xs animate-pulse">Waiting for user input...</div>
        <div id="error-log" class="error-msg hidden"></div>
    </div>

    <video id="camera_display" class="camera-bg" autoplay playsinline muted></video>
    <video id="input_video" autoplay playsinline muted></video>

    <div id="canvas-container"></div>

    <div class="absolute top-4 right-4 w-64 glass-panel p-4 text-white z-50 hidden" id="ui-panel">
        <h2 class="text-lg font-bold text-cyan-400 mb-2">HAND CONTROLLER</h2>
        
        <div class="space-y-2">
            <button onclick="changeShape('heart')" class="w-full bg-pink-900/40 hover:bg-pink-600 border border-pink-500/30 py-1 rounded text-sm">‚ù§Ô∏è Tr√°i Tim</button>
            <button onclick="changeShape('planet')" class="w-full bg-blue-900/40 hover:bg-blue-600 border border-blue-500/30 py-1 rounded text-sm">ü™ê H√†nh Tinh</button>
            <button onclick="changeShape('lotus')" class="w-full bg-green-900/40 hover:bg-green-600 border border-green-500/30 py-1 rounded text-sm">üåø Hoa Sen</button>
        </div>

        <div class="mt-4 p-2 bg-black/40 rounded text-xs">
            <p>Tr·∫°ng th√°i: <span id="hand-status" class="text-red-400 font-bold">T√¨m tay...</span></p>
            <p>Kho·∫£ng c√°ch: <span id="dist-val" class="text-cyan-400">--</span></p>
        </div>
    </div>

    <div class="absolute bottom-6 w-full text-center z-40 hidden" id="guide-text">
        <span class="bg-black/60 text-white/80 px-4 py-2 rounded-full text-sm backdrop-blur-md border border-white/10">
            Gi∆° <b>2 tay</b> l√™n tr∆∞·ªõc camera ƒë·ªÉ ƒëi·ªÅu khi·ªÉn
        </span>
    </div>

    <script>
        // --- C·∫§U H√åNH ---
        const PARTICLE_COUNT = 6000; // Gi·∫£m nh·∫π s·ªë h·∫°t cho m∆∞·ª£t mobile
        let currentShape = 'heart';
        
        // --- THREE.JS ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Texture h·∫°t
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0, 'white');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
        const texture = new THREE.Texture(canvas); texture.needsUpdate = true;

        // T·∫°o h·∫°t
        const geometry = new THREE.BufferGeometry();
        const pos = new Float32Array(PARTICLE_COUNT * 3);
        const targetPos = new Float32Array(PARTICLE_COUNT * 3);
        
        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            pos[i] = (Math.random()-0.5)*50;
            targetPos[i] = pos[i];
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const material = new THREE.PointsMaterial({ size: 0.15, map: texture, transparent: true, opacity: 0.8, color: 0x00ffff, blending: THREE.AdditiveBlending, depthWrite: false });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // H√†m t·∫°o h√¨nh (R√∫t g·ªçn)
        function calcTargets(shape) {
            const scale = 0.6;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                let x,y,z; const idx=i*3;
                if(shape === 'heart') {
                    const t = Math.random()*Math.PI*2, r = Math.random();
                    x = 16*Math.pow(Math.sin(t),3) * scale * r;
                    y = (13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)) * scale * r;
                    z = (Math.random()-0.5)*4 * scale;
                } else if(shape === 'planet') {
                    const angle = Math.random()*Math.PI*2, rad = 8 + Math.random();
                    x=rad*Math.cos(angle); z=rad*Math.sin(angle); y=(Math.random()-0.5)*2;
                } else { // Lotus default
                     const layer = i%3, t = Math.random(), ang = Math.random()*Math.PI*2;
                     const r = (2 + layer*2) + t*4;
                     x=r*Math.cos(ang); z=r*Math.sin(ang); y=t*t*5 - 2;
                }
                targetPos[idx]=x; targetPos[idx+1]=y; targetPos[idx+2]=z;
            }
        }
        calcTargets('heart');
        function changeShape(s) { currentShape=s; calcTargets(s); }

        // --- MEDIAPIPE HANDS ---
        let handScale = 1.0;
        let isHandDetected = false;

        function onResults(results) {
            // ·∫®n m√†n h√¨nh ch·ªù khi AI ƒë√£ ch·∫°y ok
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('ui-panel').style.display = 'block';
            document.getElementById('guide-text').style.display = 'block';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                isHandDetected = true;
                const h1 = results.multiHandLandmarks[0][8];
                const h2 = results.multiHandLandmarks[1][8];
                const dist = Math.sqrt(Math.pow(h1.x-h2.x, 2) + Math.pow(h1.y-h2.y, 2));
                
                // C·∫≠p nh·∫≠t scale d·ª±a v√†o kho·∫£ng c√°ch 2 tay
                const targetScale = Math.max(0.2, Math.min(5.0, dist * 5));
                handScale += (targetScale - handScale) * 0.1;

                document.getElementById('hand-status').innerHTML = '<span class="text-green-400">ƒê√£ k·∫øt n·ªëi</span>';
                document.getElementById('dist-val').innerText = dist.toFixed(2);
            } else {
                isHandDetected = false;
                document.getElementById('hand-status').innerHTML = '<span class="text-yellow-400">C·∫ßn 2 tay...</span>';
                // T·ª± ƒë·ªông xoay khi ko c√≥ tay
                particles.rotation.y += 0.005;
                handScale += (1.0 - handScale) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        // --- CAMERA SETUP ---
        async function startSystem() {
            const btn = document.getElementById('btn-start');
            const status = document.getElementById('status-msg');
            const errorLog = document.getElementById('error-log');
            
            btn.innerText = "ƒêANG K·∫æT N·ªêI...";
            status.innerText = "Requesting Camera Access...";
            
            try {
                // L·∫•y lu·ªìng camera
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 } });
                
                // G√°n v√†o th·∫ª video n·ªÅn
                const videoDisplay = document.getElementById('camera_display');
                videoDisplay.srcObject = stream;
                
                // G√°n v√†o th·∫ª video ·∫©n cho AI
                const videoInput = document.getElementById('input_video');
                videoInput.srcObject = stream;
                
                // B·∫Øt ƒë·∫ßu AI Camera Loop
                const cam = new Camera(videoInput, {
                    onFrame: async () => { await hands.send({image: videoInput}); },
                    width: 640, height: 480
                });
                cam.start();
                
                status.innerText = "H·ªá th·ªëng ƒë√£ kh·ªüi ch·∫°y...";

            } catch (err) {
                console.error(err);
                btn.innerText = "L·ªñI KH·ªûI ƒê·ªòNG";
                status.innerText = "Kh√¥ng th·ªÉ truy c·∫≠p Camera!";
                errorLog.classList.remove('hidden');
                
                if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                    errorLog.innerHTML = `‚ùå L·ªói b·∫£o m·∫≠t: Tr√¨nh duy·ªát y√™u c·∫ßu <b>HTTPS</b>.<br>N·∫øu b·∫°n ƒëang m·ªü file tr·ª±c ti·∫øp, h√£y upload l√™n Netlify/GitHub Pages.`;
                } else {
                    errorLog.innerText = "‚ùå B·∫°n ƒë√£ ch·∫∑n quy·ªÅn Camera. H√£y b·∫•m v√†o bi·ªÉu t∆∞·ª£ng ·ªï kh√≥a tr√™n thanh ƒë·ªãa ch·ªâ > Reset Permission.";
                }
            }
        }

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const posAttr = geometry.attributes.position;
            const arr = posAttr.array;
            
            // Xoay nh·∫π theo th·ªùi gian
            if(isHandDetected) {
                particles.rotation.y += 0.002;
            }

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const idx=i*3;
                let tx = targetPos[idx] * handScale;
                let ty = targetPos[idx+1] * handScale;
                let tz = targetPos[idx+2] * handScale;

                // Di chuy·ªÉn h·∫°t
                arr[idx] += (tx - arr[idx]) * 0.05;
                arr[idx+1] += (ty - arr[idx+1]) * 0.05;
                arr[idx+2] += (tz - arr[idx+2]) * 0.05;
            }
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
